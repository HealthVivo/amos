#!/usr/bin/perl -w
 
use strict;
use warnings;

# TIGR Modules
use TIGR::Foundation;

my $tigr_tf = new TIGR::Foundation;
my $PRG = $tigr_tf->getProgramInfo('name');
my $REV="1.0";
my @DEPENDS=("TIGR::Foundation");

# help info
my $HELPTEXT = qq~
Program that computes alignment coverage from a coords file

Usage: $PRG < coords_file [options]
	
  INPUT:
	coords_file	- File generated by "show-coords -c -l -o -r " in the Mummer package
			  The lines should be sorted by reference name and reference alignment start position

	Example:
            [S1]     [E1]  |     [S2]     [E2]  |  [LEN 1]  [LEN 2]  |  [% IDY]  |  [LEN R]  [LEN Q]  |  [COV R]  [COV Q]  | [TAGS]
	       9      951  |      951        1  |      943      951  |    98.63  |     1768      956  |    53.34    99.48  | J28690Ab07.q1k     1099594152246
	     112      969  |        1      866  |      858      866  |    98.50  |     1768      866  |    48.53   100.00  | J28690Ab07.q1k     1099594228366


  options:
	-m <n>		- Min coverage to display
	-M <n>		- Max coverage to display
	-merge		- Merge coverage intervals 

	-h|help		- Print this help and exit;
	-V|version	- Print the version and exit;
	-depend		- Print the program and database dependency list;
	-debug <level>	- Set the debug <level> (0, non-debug by default); 

  OUTPUT:
	Example:
		J28690Ab07.q1k	1	9	0
		J28690Ab07.q1k 	9	112	1
		J28690Ab07.q1k  112	951	2
		....	
~;
                                                                                                                                                             
my $MOREHELP = qq~
Return Codes:   0 - on success, 1 - on failure.
~;

sub processCount($$)
{
	my ($contig_name,$count_ref,$test_ref)=@_;
	my %count=%$count_ref;
	my %test=%$test_ref;
	
	#display clone coverage
	my $count=0;
	
	my @keys=sort {$a <=> $b} keys %count;	
	my $n=scalar(@keys);
	 
	foreach my $i (1..$n-1)
	{
		$count{$keys[$i]}+=$count{$keys[$i-1]}
	}

	if($test{merge})
	{
		my @del;
		
		if($test{m})
		{
			foreach my $i (1..$n-2)
			{
				if($count{$keys[$i-1]}>=$test{m} and $count{$keys[$i]}>=$test{m})
				{
					push @del,$keys[$i];
				}
			}
		}

                if($test{M})
                {
                        foreach my $i (1..$n-2)
                        {
				if($count{$keys[$i-1]}<=$test{M} and $count{$keys[$i]}<=$test{M})
				{
					push @del,$keys[$i];
				}
                        }
                }

		foreach (@del)
		{
			delete $count{$_};
		}
	}

        @keys=sort {$a <=> $b} keys %count;
        $n=scalar(@keys);

        foreach my $i (1..$n-1)
        {
		next if(defined($test{m}) and $count{$keys[$i-1]}<$test{m});
		next if(defined($test{M}) and $count{$keys[$i-1]}>$test{M});

                print join "\t",($contig_name,$keys[$i-1],$keys[$i],$keys[$i]-$keys[$i-1],$count{$keys[$i-1]});
		print "\n";
        }
}


	
###############################################################################
#
# Main program
#
###############################################################################

MAIN:
{
	# Configure TIGR Foundation
	$tigr_tf->setHelpInfo($HELPTEXT.$MOREHELP);
        $tigr_tf->setUsageInfo($HELPTEXT);
        $tigr_tf->setVersionInfo($REV);
        $tigr_tf->addDependInfo(@DEPENDS);
	
	# validate input parameters
	my %test;

	my $result = $tigr_tf->TIGR_GetOptions(
		"m=s" => \$test{m},
		"M=s" => \$test{M},
		"merge"	=> \$test{merge}
		);
	$tigr_tf->printUsageInfoAndExit() if (!$result);

	# parse the .contig file
	my %count;
	my $contig_name;

	while(<>)
	{

                #      0       1    2      3         4   5      6         7   8    9     10     11       12   13   14         15   16 17                18           

		#    [S1]     [E1]  |     [S2]     [E2]  |  [LEN 1]  [LEN 2]  |  [% IDY]  |  [LEN R]  [LEN Q]  |  [COV R]  [COV Q]  | [TAGS]
		#===============================================================================================================================
		#       9      951  |      951        1  |      943      951  |    98.63  |     1768      956  |    53.34    99.48  | J28690Ab07.q1k     1099594152246      
		#     112      969  |        1      866  |      858      866  |    98.50  |     1768      866  |    48.53   100.00  | J28690Ab07.q1k     1099594228366

		my @f=split;
		next unless $f[0];		
		next unless ($f[0]=~/^\d+$/ and $f[1]=~/^\d+$/ and $f[11]=~/^\d+$/) ;
		next unless(scalar(@f)>=19);

		if($contig_name and $f[17] ne $contig_name)
		{
			#display clone coverage
			&processCount($contig_name,\%count,\%test);
			%count=();	
		}	

                        
		$count{1}+=0;
                $count{$f[11]}+=0;

		$count{$f[0]}++;
		$count{$f[1]}--;

		$contig_name=$f[17];
	}
	
	#display clone coverage
	&processCount($contig_name,\%count,\%test) if ($contig_name);

	exit 0;
}
