#!/usr/local/bin/perl

use TIGR::AmosLib;
use TIGR::Foundation;

use strict;

my $VERSION = '$Revision$ ';
my $HELP = q~
    amos2frg [-i infile] [-o outfile] [-a accession]

    if -i and -o are not provided reads from STDIN and writes to STDOUT
    if -i is provided but -o is not, outfile is same as infile except for the
  extension
    otherwise -i and -o are those specified in the command line
    if -i is provided the filename must end in .afg
    if -a is specified starts numbering output at specified accession, else
  the accessions from the input file are used in the output
~;

my $base = new TIGR::Foundation();
if (! defined $base) {
    die("A horrible death\n");
}


$base->setVersionInfo($VERSION);
$base->setHelpInfo($HELP);

my $infile;
my $outfile;
my $inname = "stdin";
my $accession = 1;
my $date = time();
my $firstunv = 1;
my %libids;
my %frg2lib;
my %rd2lib;
my %rdids;

my $err = $base->TIGR_GetOptions("i=s"   => \$infile,
				 "o=s"   => \$outfile,
				 "a=i"   => \$accession);



# if infile is provided, make sure it ends in .afg and open it
if (defined $infile){
    if ($infile !~ /\.afg$/){
	$base->bail ("Input file name must end in .afg");
    }
    $inname = $infile;
    open(STDIN, "$infile") || $base->bail("Cannot open $infile: $!\n");
}

# if infile is provided but outfile isn't make outfile by changing the extension
if (! defined $outfile && defined $infile){
    $outfile = $infile;
    $outfile =~ s/(.*)\.afg$/\1.frg/;
}

# if outfile is provided (or computed above) simply open it
if (defined $outfile){
    open(STDOUT, ">$outfile") || $base->bail("Cannot open $outfile: $!\n");
}

while (my $record = getRecord(\*STDIN)){
    my ($type, $fields, $recs) = parseRecord($record);
    my $acc;

    $acc = $accession++;

#    print "Got $type\n";
    if ($type eq "UNV"){
	next unless $firstunv;
	
	/`/; 

	print qq~{BAT
bna:CeleraAssembler
crt:$date
acc:$acc
com:
.
}
{ADT
{ADL
who:
ctm:$date
vsn:1.00
com:
Generated by $0 from file: $inname
.
}
{ADL
who:
ctm:$date
vsn:1.00
com:
AMOS UNV header
$$fields{com}.
}
.
}
~;

/`/; 
        $firstunv = 0;
    } # type is UNV

    if ($type eq "LIB"){
	# only use the first DST record  
	if ($#$recs < 0){
	    $base->bail("LIB record doesn't have any DST record at or around line $. in input");
	}
	$libids{$$fields{"iid"}} = $acc;
        my ($sid, $sfs, $srecs) = parseRecord($$recs[0]);
	if ($sid ne "DST"){
	    $base->bail("LIB record doesn't start with DST record at or around line $. in input");
	}
        if ($$sfs{mea} == 0) {
          $$sfs{mea} = 10;
        }
        if ($$sfs{std} == 0) {
          $$sfs{std} = 3;
        }
	/`/;
print qq~{DST
act:A
acc:$acc
mea:$$sfs{mea}
std:$$sfs{std}
}
~;
/`/;
    } # type is LIB
    
    if ($type eq "FRG"){
	$frg2lib{$$fields{"iid"}} = $$fields{"lib"};
    } # type is FRG

    if ($type eq "RED"){
	$rd2lib{$$fields{"iid"}} = $frg2lib{$$fields{"frg"}};
	$rdids{$$fields{"iid"}} = $acc;
	
/`/;
print qq~{FRG
act:A
acc:$acc
typ:R
src:
$$fields{eid}
.
etm:0
seq:
$$fields{seq}.
qlt:
$$fields{qlt}.
clr:$$fields{clr}
}
~;
/`/;

    } # type is RED
    if ($type eq "MTP"){
 
       if ($rd2lib{$$fields{rd1}} != $rd2lib{$$fields{rd2}}){
          $base->bail("Reads $$fields{rd1} and $$fields{rd2} don't appear to map to the same library ($rd2lib{$$fields{rd1}} != $rd2lib{$$fields{rd2}})");
       }
/`/;
print qq~{LKG
act:A
typ:M
fg1:$rdids{$$fields{rd1}}
fg2:$rdids{$$fields{rd2}}
etm:0
dst:$libids{$rd2lib{$$fields{rd1}}}
ori:I
}
~;
/`/;
    } # type is MTP
} # while each record

exit(0);
